启用哪种垃圾回收
如：-XX:+UseSerialGC

一 如何判定对象为垃圾对象？
1.1 引用计数法
在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1；
可以打印gc的信息
-verbose:gc
-XX:+PrintGCDetails
1.2 可达性分析法
作为GCRoots的对象：
1.2.1 虚拟机栈
1.2.2 方法区的类属性所引用的对象
1.2.3 方法区中常量所引用的对象
1.2.4 本地方法栈中引用的对象
二 如何回收？
2.1 回收的策略
2.1.1 标记清除
效率问题
空间问题
针对老年代使用标记清除
2.1.2 复制算法
堆
新生代（Minor GC即Young GC）
Eden伊甸园
Survivor存活区
Tenured Gen
老年代（Major GC即Full GC）
方法区
栈 本地方法栈 程序计数器
2.1.3 标记整理
2.1.4 分代回收
2.2 垃圾收集器
三 何时回收？
3.1 Serial收集器
最基本，发展最悠久
单线程垃圾收集器
3.2 Parnew收集器
是Serial收集器的多线程版本
3.3 Parallel Scavenge收集器
复制算法（新生代收集器）
多线程收集器
达到可控制的吞吐量
-XX:MaxGFPauseMillis垃圾收集器最大停顿时间，如1，即1毫秒
-XX:GCTimeRatio设置吞吐量大小（0，100）
3.4 Cms收集器
3.4.1 工作过程
初始标记
并发标记
重新标记
并发清理
3.4.2 有点
并发收集
低停顿
3.4.3 缺点
占用大量的CPU资源
无法处理浮动垃圾
出现Concurrent Mode Failure
空间碎片
3.5 G1收集器
3.5.1 优势
并行和并发
分代回收
空间整合
可预测的停顿
3.5.2 步骤
初始标记
并发标记
最终标记
筛选回收
