
一 线程共享区【执行引擎】
堆和方法区
1.1 堆
存放对象实例
垃圾收集器管理的主要区域
新生代（Eden空间，Survivor空间），老年代
OutOfMemoryError
分配空间：-Mxs20m -Mxm20m
1.2 方法区
包括：类的信息和常量池
存储虚拟机加载的类信息，常量，静态变量，即编辑器编译后的代码等数据；
类信息：版本，字段，方法，接口
方法区和永久代
垃圾回收在方法区的行为（简单提下）
异常的定义（OutOfMemoryError）

二 线程独占区【本地库接口】
程序计数器（PC）
Java虚拟机栈
本地方法栈
2.1 程序计数器
是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器；
如果线程执行的是Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址。
如果正在执行的是native方法，这个计数器的值为undefined。
此区域是唯一一个没有规定OOM情况的区域；
2.2 Java虚拟机栈
描述的是Java执行的动态内存模型；
栈帧：每个方法执行，都会创建一个栈帧，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等；
局部变量表：存放编译器可知的各种基本数据类型，引用类型，returnAddress类型；
局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，在方法运行期间是不会改变局部变量表的大小；
报错：StackOverflowError，如代码->StackOverFlowTest.java
2.3 本地方法栈
虚拟机栈为虚拟机执行Java方法服务
本地方法栈为虚拟机执行native方法服务

三 直接内存
也会出现OOM异常


